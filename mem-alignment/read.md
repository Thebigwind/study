什么时候需要开辟内存块？
在Go中，在下列场合（不限于）将发生开辟内存块的操作：
1.显式地调用new和make内置函数。 一个new函数调用总是只开辟一个内存块。 一个make函数调用有可能会开辟多个内存块来承载创建的切片/映射/通道值的直接和底层间接值部。
2.使用字面量创建映射、切片或函数值。在此创建过程中，一个或多个内存块将被开辟出来。
3.声明变量。
4.将一个非接口值赋给一个接口值。（对于标准编译器来说，不包括将一个指针值赋给一个接口值的情况。）
5.衔接非常量字符串。
6.将字符串转换为字节切片或者码点切片，或者反之，除了一些编译器优化情形。
7.将一个整数转换为字符串。
8.调用内置append函数并且基础切片的容量不足够大。
9.向一个映射添加一个键值条目并且此映射底层内部的哈希表需要改变容量。


内存块将被开辟在何处？
对每一个使用标准编译器编译的Go程序，在运行时刻，每一个协程将维护一个栈（stack）。 
一个栈是一个预申请的内存段，它做为一个内存池供某些内存块从中开辟。 
每个协程的初始栈大小比较小（在64位系统上大概2千字节）。 
每个栈的大小在协程运行的时候将按照需要增长和收缩。

注意：对于标准编译器来说，每个协程维护的栈的大小有一个最大限制。 
对于Go官方工具链1.11中编译器来说，此最大限制的默认值在64位系统上为1GB，在32位系统上为250MB。 
我们可以在运行时刻调用runtime/debug标准库包中的SetMaxStack来修改此值。）

内存块可以被开辟在栈上。开辟在一个协程维护的栈上的内存块只能在此协程内部被使用（引用）。 
其它协程是无法访问到这些内存块的。 一个协程可以无需使用任何数据同步技术而使用开辟在它的栈上的内存块上的值部。

堆（heap）是一个虚拟的概念。每个程序只有一个堆。 一般地，如果一个内存块没有开辟在任何一个栈上，则我们说它开辟在了堆上。
开辟在堆上的内存块可以被多个协程并发地访问。 在需要的时候，对承载在它们之上的值部的访问需要做同步。

如果编译器觉察到一个内存块在运行时将会被多个协程访问，或者不能轻松地断定此内存块是否只会被一个协程访问，则此内存块将会被开辟在堆上。 
也就是说，编译器将采取保守但安全的策略，使得某些可以安全地被开辟在栈上的内存块也有可能会被开辟在堆上。

栈对于Go程序来说并非必要。Go程序中所有的内存块都可以开辟在堆上。 支持栈只是为了让Go程序的运行效率更高。
1.从栈上开辟内存块比在堆上快得多；
2.开辟在栈上的内存块不需要被垃圾回收；
3.开辟在栈上的内存块对CPU缓存更加友好。

如果一个局部声明的变量的某些值部被开辟在堆上，则我们说这些值部以及此局部变量逃逸到了堆上。
可以运行Go官方工具链中提供的go build -gcflags -m命令来查看代码中哪些局部值的值部在运行时刻会逃逸到堆上


在运行时刻，每一个仍在被使用中的逃逸到堆上的值部肯定被至少一个开辟在栈上的值部所引用着。 
如果一个逃逸到堆上的值是一个被声明为T类型的局部变量，则在运行时，一个*T类型的隐式指针将被创建在栈上。 
此指针存储着此T类型的局部变量的在堆上的地址，从而形成了一个从栈到堆的引用关系。
*T值可能从今后的某一时刻不再被使用从而使得此引用关系不再存在。 此引用关系在下面介绍的垃圾回收过程中发挥着重要的作用。

我们可以认为每个包级变量（常称全局变量）都被开辟在了堆上，并且它被一个开辟在一个全局内存区上的隐式指针所引用着。
此指针引用着此包级变量的直接部分，此直接部分又引用着其它的值（部）。

一个开辟在堆上的内存块可能同时被开辟在若干不同栈上的值部所引用着。

如果一个结构体值的一个字段逃逸到了堆上，则此整个结构体值也逃逸到了堆上。
如果一个数组的某个元素逃逸到了堆上，则此整个数组也逃逸到了堆上。
如果一个切片的某个元素逃逸到了堆上，则此切片中的所有元素都将逃逸到堆上，但此切片值的直接部分可能开辟在栈上。
如果一个值部v被一个逃逸到了堆上的值部所引用，则此值部v也将逃逸到堆上。



Go中的类型对齐保证（alignment guarantee）
类型对齐保证也称为值地址对齐保证。 如果一个类型T的对齐保证为N（一个正整数），则在运行时刻T类型的每个（可寻址的）值的地址都是N的倍数。 我们也可以说类型T的值的地址保证为N字节对齐的。

事实上，每个类型有两个对齐保证。当它被用做结构体类型的字段类型时的对齐保证称为此类型的字段对齐保证，其它情形的对齐保证称为此类型的一般对齐保证。

即使对于同一个编译器，具体类型的对齐保证在不同的架构上也是不相同的。
同一个编译器的不同版本做出的具体类型的对齐保证也有可能是不相同的。

当前版本（1.15）的标准编译器做出的对齐保证列在了下面：
类型种类                   对齐保证（字节数）
------                    ------
bool, byte, uint8, int8   1
uint16, int16             2
uint32, int32             4
float32, complex64        4
数组                       取决于元素类型
结构体类型                  取决于各个字段类型
其它类型                    一个自然字的尺寸


这里，一个自然字（native word）的尺寸在32位的架构上为4字节，在64位的架构上为8字节。
这意味着，对于当前版本的标准编译器，其它类型的对齐保证为4或者8，具体取决于程序编译时选择的目标架构。 此结论对另一个流行Go编译器gccgo也成立。


类型的尺寸和结构体字节填充（structure padding）
Go白皮书只对以下种类的类型的尺寸进行了明确规定。
类型种类                  尺寸（字节数）
------                   ------
byte, uint8, int8        1
uint16, int16            2
uint32, int32, float32   4
uint64, int64            8
float64, complex64       8
complex128               16
uint, int                取决于编译器实现。通常在 32位架构上为4，在64位架构上为8。
uintptr                  取决于编译器实现。但必须能够存下任一个内存地址。


Go编译器可能会在结构体的相邻字段之间填充一些字节。 这使得一个结构体类型的尺寸并非等于它的各个字段类型尺寸的简单相加之和。
下面是一个展示了一些字节是如何填充到一个结构体中的例子。
首先，从上面的描述中，我们已得知（对于标准编译器来说）：

1.内置类型int8的对齐保证和尺寸均为1个字节； 内置类型int16的对齐保证和尺寸均为2个字节； 内置类型int64的尺寸为8个字节，但它的对齐保证在32位架构上为4个字节，在64位架构上为8个字节。
2.下例中的类型T1和T2的对齐保证均为它们的各个字段的最大对齐保证。 所以它们的对齐保证和内置类型int64相同，即在32位架构上为4个字节，在64位架构上为8个字节。
3.类型T1和T2尺寸需为它们的对齐保证的倍数，即在32位架构上为4n个字节，在64位架构上为8n个字节。

type T1 struct {
a int8

    // 在64位架构上，为了让字段b的地址为8字节对齐，
    // 需在这里填充7个字节。在32位架构上，为了让
    // 字段b的地址为4字节对齐，需在这里填充3个字节。

    b int64
    c int16

    // 为了让类型T1的尺寸为T1的对齐保证的倍数，
    // 在64位架构上需在这里填充6个字节，在32架构
    // 上需在这里填充2个字节。
}
// 类型T1的尺寸在64位架构上位24个字节（1+7+8+2+6），
// 在32位架构上为16个字节（1+3+8+2+2）。

type T2 struct {
a int8

    // 为了让字段c的地址为2字节对齐，
    // 需在这里填充1个字节。

    c int16

    // 在64位架构上，为了让字段b的地址为8字节对齐，
    // 需在这里填充4个字节。在32位架构上，不需填充
    // 字节即可保证字段b的地址为4字节对齐的。

    b int64
}
// 类型T2的尺寸在64位架构上位16个字节（1+1+2+4+8），
// 在32位架构上为12个字节（1+1+2+8）。
从这个例子可以看出，尽管类型T1和T2拥有相同的字段集，但是它们的尺寸并不相等。


一个内存块在什么条件下可以被回收？
1.为包级变量的直接部分开辟的内存块永远不会被回收。
2.每个协程的栈将在此协程退出之时被整体回收，此栈上开辟的各个内存块没必要被一个一个单独回收。 栈内存池并不由垃圾回收器回收。
3.对一个开在堆上的内存块，当它不再被任何开辟在协程栈的仍被使用中的，以及全局内存区上的，值部所（直接或者间接）地引用着,将在以后某个时刻被垃圾回收器回收掉。




如何判断一个内存块是否仍在被使用？
使用一个并发三色（tri-color）标记清扫（mark-sweep）算法来实现垃圾回收。

一个垃圾回收过程分为两个阶段：标记阶段和清扫阶段。

在标记阶段，垃圾回收器（实际上是一组协程）使用三色算法来分析哪些（开辟在堆上的）内存块已经不再使用了。

在每一轮（见下一节的解释）垃圾回收过程的开始，所有的内存块将被标记为白色。
然后垃圾回收器将所有开辟在栈和全局内存区上的内存块标记为灰色，并把它们加入一个灰色内存块列表。
循环下面两步直到灰色内存块列表为空：
从个灰色内存块列表中取出一个内存块，并把它标记为黑色。
然后扫描承载在此内存块上的指针值，并通过这些指针找到它们引用着的内存块。 如果一个引用着的内存块为白色的，则将其标记为灰色并加入灰色内存块列表；否则，忽略之。
（注意这里在算法中使用三色而不是两色的原因是此标记过程是并发的。在标记的过程中，很多其它普通用户协程也正在运行中。 在此标记过程中对指针的写入需要一些额外的开销，欲更深入了解此点，请以“write barrier golang”为关键字自行搜索以深入了解。 简而言之，当在某个用户协程中，一个已经标记为黑色的内存块在标记过程中被修改而使其新引用着的一个仍标记为白色的内存块时，此白色内存块需要被标记为灰色，否则此白色内存块有可能将被认为是垃圾而回收掉；除此之外的情况不做特殊处理。）

在清扫阶段，仍被标记为白色的内存块将被认为是不再使用的而被回收掉。

此垃圾回收算法不会移动内存块来整理内存碎片。
