package main

import (
	"fmt"
	"runtime"
	"time"
)

/*
单核 CPU，开两个 Goroutine，其中一个死循环，会怎么样？

设置 runtime.GOMAXPROCS 方法模拟了单核 CPU 下只有一个 P 的场景。
运行一个 Goroutine，内部跑一个 for 死循环，达到阻塞运行的目的。
运行一个 Goroutine，主函数（main）本身就是一个 Main Goroutine

答案是：

在 Go1.14 前，不会输出任何结果。
在 Go1.14 及之后，能够正常输出结果。

在1.14前
这段程序是有一个 Goroutine 是正在执行死循环，也就是说他肯定无法被抢占。

这段程序中更没有涉及主动放弃执行权的调用（runtime.Gosched），又或是其他调用（可能会导致执行权转移）的行为。 因此这个 Goroutine 是没机会溜号的，只能一直打工…

那为什么主协程（Main Goroutine）会无法运行呢，其实原因是会优先调用休眠，但由于单核 CPU，其只有唯一的 P。唯一的 P 又一直在打工不愿意下班（执行 for 死循环，被迫无限加班）。


在1.14后
Go1.14 实现了基于信号的抢占式调度，以此来解决上述一些仍然无法被抢占解决的场景。

主要原理是Go 程序在启动时，会在 runtime.sighandler 方法注册并且绑定 SIGURG 信号：
绑定相应的 runtime.doSigPreempt 抢占方法：


同时在调度的 runtime.sysmon 方法会调用 retake 方法处理一下两种场景：

抢占阻塞在系统调用上的 P。
抢占运行时间过长的 G。
该方法会检测符合场景的 P，当满足上述两个场景之一。就会发送信号给 M， M 收到信号后将会休眠正在阻塞的 Goroutine，调用绑定的信号方法，并进行重新调度。以此来解决这个问题。




*/
func main() {
	// 模拟单核 CPU
	runtime.GOMAXPROCS(1)

	// 模拟 Goroutine 死循环
	go func() {
		for {
		}
	}()

	time.Sleep(time.Millisecond)
	fmt.Println("脑子进煎鱼了")
}

/*

为什么要抢占 P
为什么会要想去抢占 P 呢，说白了就是不抢，就没机会运行，会 hang 死。又或是资源分配不均了，

这在调度器设计中显然是不合理的。

至此完成了抢占 P 的基本流程，我们可得出满足以下条件：

如果存在系统调用超时：存在超过 1 个 sysmon tick 周期（至少 20us）的任务，则会从系统调用中抢占 P。
如果没有空闲的 P：所有的 P 都已经与 M 绑定。需要抢占当前正处于系统调用之，而实际上系统调用并不需要的这个 P 的情况，会将其分配给其它 M 去调度其它 G。
如果 P 的运行队列里面有等待运行的 G，为了保证 P 的本地队列中的 G 得到及时调度。而自己本身的 P 又忙于系统调用，无暇管理。此时会寻找另外一个 M 来接管 P，从而实现继续调度 G 的目的。


*/
