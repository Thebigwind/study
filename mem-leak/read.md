使用new函数得到的内存不一定就在堆上。堆和栈的区别对程序员“模糊化”了，一切都是Go编译器在背后帮我们完成的。


对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。

1.如果函数外部没有引用，则优先放到栈中；
2.如果函数外部存在引用，则必定放到堆中；


1.指针逃逸
如果一个函数返回对一个局部变量的引用，那么它就会发生逃逸。

2.栈空间不足逃逸
Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。
func Slice() {
s := make([]int, 1000, 1000)

    for index, _ := range s {
        s[index] = index
    }
}

go build -gcflags=-m



3.动态类型逃逸
很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也会产生逃逸。


4.闭包引用对象逃逸
Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸


5.
栈上分配内存比在堆中分配内存有更高的效率
栈上分配的内存不需要GC处理
堆上分配的内存使用完毕会交给GC处理
逃逸分析目的是决定内分配地址是栈还是堆
逃逸分析在编译阶段完成

5编程Tips
思考一下这个问题：函数传递指针真的比传值效率高吗？

我们知道传递指针可以减少底层值的拷贝，可以提高效率，
但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。