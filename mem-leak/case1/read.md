package main

//子字符串造成的暂时性内存泄露
/*


Go白皮书并没有说明一个子字符串表达式的结果（子）字符串和基础字符串是否应该共享一个承载底层字节序列的内存块。
但标准编译器确实让它们共享一个内存块，而且很多标准库包的函数原型设计也默认了这一点。
这是一个好的设计，它不仅节省内存，而且还减少了CPU消耗。
但是有时候它会造成暂时性的内存泄露。
*/

var s0 string // 一个包级变量

// 一个演示目的函数。
func f(s1 string) {
	s0 = s1[:50]
	// 目前，s0和s1共享着承载它们的字节序列的同一个内存块。
	// 虽然s1到这里已经不再被使用了，但是s0仍然在使用中，
	// 所以它们共享的内存块将不会被回收。虽然此内存块中
	// 只有50字节被真正使用，而其它字节却无法再被使用。
}

func demo() {
	s := createStringWithLengthOnHeap(1 << 20) // 1M bytes
	f(s)
}

//为防止上面的f函数产生临时性内存泄露，我们可以将子字符串表达式的结果转换为一个字节切片，然后再转换回来。
func f(s1 string) {
	s0 = string([]byte(s1[:50]))
}

